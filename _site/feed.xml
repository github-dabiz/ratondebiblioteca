<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ratón de Biblioteca</title>
    <description>Ratón de Biblioteca es un blog dedicado al diseño de software en el ecosistema Java.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 24 Sep 2022 10:46:36 +0200</pubDate>
    <lastBuildDate>Sat, 24 Sep 2022 10:46:36 +0200</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Pruebas de Software: Tipología</title>
        <description>&lt;p&gt;Este post es el inicio de una serie en la que trataré de profundizar en los distintos tipos de pruebas de software, en cuanto a objetivos que persiguen, planteamiento, ejecución y otras características de interés. Como punto de partida, se va a exponer una categorización de pruebas de software que enlazará directamente con sus post específicos en los casos en los que aplique. En el resto de casos, simplemente quedarán indicadas en este post como parte de la jerarquía.&lt;/p&gt;

&lt;h2 id=&quot;criterios-de-clasificación&quot;&gt;Criterios de clasificación&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Tipo de ejecución&lt;/li&gt;
  &lt;li&gt;Aproximación al problema&lt;/li&gt;
  &lt;li&gt;Objeto de verificación&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tipo-de-ejecución&quot;&gt;Tipo de ejecución&lt;/h2&gt;

&lt;p&gt;Atendiendo al tipo de ejecución las pruebas de software pueden clasificarse como:&lt;/p&gt;

&lt;h3 id=&quot;automáticas&quot;&gt;Automáticas&lt;/h3&gt;

&lt;p&gt;Este tipo de pruebas son ejecutadas por máquinas, generalmente se ejecutan mediante scripts.&lt;/p&gt;

&lt;p&gt;Algunas de sus ventajas respecto a las pruebas manuales son:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;su ejecución es más rápida&lt;/li&gt;
  &lt;li&gt;son más fiables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Entre sus inconvenientes se encuentran:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;su calidad depende de la calidad de los scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sin embargo, por su naturaleza, las pruebas automáticas son un componente clave tanto para la integración continua como para la entrega continua y, por tanto, para asegurar la calidad del software.&lt;/p&gt;

&lt;h3 id=&quot;manuales&quot;&gt;Manuales&lt;/h3&gt;

&lt;p&gt;Se trata de pruebas llevadas a cabo por personas, que interactúan con el software verificando su correcto funcionamiento&lt;/p&gt;

&lt;p&gt;El principal inconveniente de este tipo de pruebas es su coste, ya que se requiere personal dedicado a la ejecución de pruebas.
Otro inconveniente es que el resultado se puede afectado por el error humano.&lt;/p&gt;

&lt;p&gt;Entonces, ¿por qué realizar pruebas manuales?. Pues porque los test manuales probar en profundidad nuevas características del producto, para verificar su funcionamiento, proporcionar feedback de usabilidad y experiencia de usuario. Las pruebas automáticas tienen sentido sobre todo en los casos de pruebas de regresión para asegurar que las nuevas características no han introducido bugs en las funcionalidades anteriores.&lt;/p&gt;
&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://unsplash.com/@girlwithredhat?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&amp;quot;&quot;&gt;Foto de Girl with Red Hat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://es.wikipedia.org/wiki/Pruebas_de_software&quot;&gt;Pruebas de software - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_testing&quot;&gt;Software testing - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programacionymas.com/blog/tipos-de-testing-en-desarrollo-de-software&quot;&gt;Programación y más&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arbusta.net/testing-automation-manual-diferencias/&quot;&gt;Arbusta&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bbvanexttechnologies.com/blogs/el-gran-dilema-del-qa-automatizacion-o-testing-manual/&quot;&gt;El gran dilema del QA: ¿Automatización o testing manual?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 26 Aug 2022 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/pruebas-software</link>
        <guid isPermaLink="true">http://localhost:4000/pruebas-software</guid>
        
        <category>QA</category>
        
        <category>Testing</category>
        
        
      </item>
    
      <item>
        <title>OAuth 2.0: Código de Autorización</title>
        <description>&lt;p&gt;En el anterior post &lt;a href=&quot;./oauth2&quot;&gt;Autorización a Recursos: OAuth 2.0&lt;/a&gt; se realizó una primera aproximación conceptual a OAuth2. En este segundo post, el objetivo es introducir algunos elementos más, que quedaron pendientes, así como profundizar a nivel técnico en el flujo más habitual de los Grant Types, el Código de Autorización&lt;/p&gt;

&lt;h2 id=&quot;protocolo-de-comunicación&quot;&gt;Protocolo de Comunicación&lt;/h2&gt;

&lt;p&gt;Además de los actores y el flujo conversacional, para entender bien todos los pasos que se dan desde la petición de autorización inicial, hasta la obtención de la información por parte del cliente, hay que conocer tanto el protocolo que se utiliza para transmitir la información como sum intérprete.&lt;/p&gt;

&lt;p&gt;OAuth2 es un framework pensado para implementarse mediante protocolo de comunicación HTTP, basado en el principio de cliente-servidor. Las peticiones son enviadas por una entidad: el agente del usuario (o un proxy a petición de uno). La mayoría de las veces el agente del usuario (cliente) es un navegador Web, pero podría ser cualquier otro programa.&lt;/p&gt;

&lt;p&gt;El intérprete es el elemento que articula la comunicación entre todos los actores, Usuario - Aplicación Cliente, Usuario - Servidor de autorización, y en menor medida Aplicación Cliente - Servidor de Recursos. En este último caso, intervienen en las redirecciones HTTP.&lt;/p&gt;

&lt;p&gt;Aunque también importante, no se va a profundizar en la estructura de la petición y respuesta HTTP por considerar que queda fuera del alcance de artículo, aunque se puede encontrar una descripción detallada en &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/es/docs/Web/HTTP/Overview&quot;&gt;Generalidades del protocolo HTTP&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;registro-de-la-aplicación-cliente&quot;&gt;Registro de la Aplicación Cliente&lt;/h2&gt;

&lt;p&gt;Un paso importante que no se suele mencionar al explicar el flujo abstracto o flujo lógico de OAuth2, es el registro de la Aplicación Cliente en el Servidor de Autorización. Antes de que la Aplicación Cliente esté en condiciones de solicitar la autorización al Usuario y comunicarse con el Servidor de Autorizaciones, es necesario que este último la tenga registrada como una aplicación de confianza. Generalmente, esto se hace a través de un formulario de registro en la sección de “desarrolladores” o “API” del sitio web del Servidor de Recursos.&lt;/p&gt;

&lt;p&gt;Uno de los datos que será necesario proporcionar, es la URI a la que ese deber redireccionar una vez que el usuario haya dado su autorización. En consecuencia, será un endpoint de la Aplicación Cliente en el que manejarán códigos de autorización o tokens de acceso.&lt;/p&gt;

&lt;p&gt;Durante el proceso de registro, el Servidor de Autorizaciones, proporcionará al Cliente un identificador (CLIENT_ID), y un secreto (SECRET). El primero, es una cadena pública que identifica a la Aplicación Cliente, y el secreto se utiliza para verificar la identidad del Cliente, por lo que debe estar protegido de posibles ataques para evitar suplantaciones de identidad.&lt;/p&gt;

&lt;h2 id=&quot;token-de-acceso&quot;&gt;Token de acceso&lt;/h2&gt;

&lt;p&gt;Es el elemento que otorga el Servidor de Autorización a la Aplicación Cliente para realizar solicitudes en nombre del usuario. Se utilizará en la comunicación entre el Servidor de Recursos y la Aplicación Cliente para verificar los privilegios de acceso, la autorización.&lt;/p&gt;

&lt;p&gt;Los tokens de acceso no tienen por qué tener un formato determinado. Pueden ser Bearer Tokens (al portador) o Sender-constrained (restringidos al emisor). Los tokens restringidos al emisor requieren que el cliente de OAuth demuestre la posesión de una clave privada para poder utilizar el token de acceso, de manera que el token de acceso por sí mismo no sería utilizable.&lt;/p&gt;

&lt;p&gt;Hay una serie de propiedades de los tokens de acceso que son fundamentales para el modelo de seguridad de OAuth:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No deben ser leídos o interpretados por el cliente OAuth. El cliente OAuth no es el destinatario del token.&lt;/li&gt;
  &lt;li&gt;No transmiten al cliente OAuth la identidad del usuario ni ninguna otra información sobre el mismo.&lt;/li&gt;
  &lt;li&gt;Solo deben utilizarse para realizar solicitudes al servidor de recursos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Existen distintos tipos de token que se aplican en diferentes escenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Access Token&lt;/li&gt;
  &lt;li&gt;ID Token&lt;/li&gt;
  &lt;li&gt;Refresh Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los tokens de acceso se definen en OAuth, los tokens de identificación se definen en OpenID Connect.&lt;/p&gt;

&lt;p&gt;Los tokens de acceso son lo que el cliente de OAuth utiliza para hacer peticiones a una API. El token de acceso está destinado a ser validado por la API. Un token de identificación contiene información sobre lo que sucedió cuando un usuario se autenticó, y está destinado a ser leído por el cliente de OAuth. El token de identificación también puede contener información sobre el usuario, como su nombre o dirección de correo electrónico, aunque esto no es un requisito de un token de identificación.&lt;/p&gt;

&lt;p&gt;Aquí hay algunas otras diferencias entre los tokens de identificación y los tokens de acceso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Los tokens de identificación están pensados para ser leídos por el cliente OAuth. Los tokens de acceso están destinados a ser leídos por el servidor de recursos.&lt;/li&gt;
  &lt;li&gt;Los tokens de identificación son JWTs. Los tokens de acceso pueden ser JWTs pero también pueden ser una cadena aleatoria.&lt;/li&gt;
  &lt;li&gt;Los tokens de identificación nunca deben ser enviados a una API. Los tokens de acceso nunca deben ser leídos por el cliente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por otro lado, un Refresh Token en OAuth2 es una cadena que el cliente de OAuth puede utilizar para obtener un nuevo token de acceso sin la interacción del usuario. No debe permitir al cliente obtener ningún acceso más allá del alcance de la concesión original. Existe para permitir a los servidores de autorización utilizar tiempos de vida cortos para los tokens de acceso sin necesidad de involucrar al usuario cuando el token expira.&lt;/p&gt;

&lt;p&gt;## Scopes&lt;/p&gt;

&lt;p&gt;Los &lt;strong&gt;&lt;em&gt;scopes&lt;/em&gt;&lt;/strong&gt; en OAuth2 se utilizan para identificar los recursos a los que puede tener acceso la Aplicación Cliente. Cuando el cliente solicita la autorización al Servidor de Autorización, envía la lista de ámbitos para los que se solicita. El Servidor de Autorizaciones utiliza esta lista de ámbitos para generar la pantalla de consentimiento que presentará al usuario durante el proceso de Autorización. Si el usuario acepta, el Servidor de Autorización emite un token con el código de autorización.&lt;/p&gt;

&lt;h2 id=&quot;respuesta-oauth&quot;&gt;Respuesta OAuth&lt;/h2&gt;

&lt;p&gt;La respuesta de todos los Grant Types producen un formato de salida semejante, una estructura JSON con los siguientes valores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;access_token&lt;/em&gt;&lt;/strong&gt; (requerido) Cadena cifrada que se utilizará posteriormente para autorizar las peticiones.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;token_type&lt;/em&gt;&lt;/strong&gt; (requerido) Identifica el tipo de token, se suele utilizar el tipo “Bearer”.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;expires_in&lt;/em&gt;&lt;/strong&gt; (recomendado) Indica la duración en segundos del access_token. Una vez caduca puede ser renovado usando el Grant Type de Refresh Token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;refresh_token&lt;/em&gt;&lt;/strong&gt; (opcional) Permiten volver a generar el un token de acceso. Se solicitará su valor durante el proceso de Refresh Token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;scope&lt;/em&gt;&lt;/strong&gt; (opcional) Indica el ámbito de uso del access token. La AC solicitará información de un scope concreto durante la obtención del token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;id_token&lt;/em&gt;&lt;/strong&gt; (opcional) Si se utiliza un scope con valor “openid”, puede significar que se quiere utilizar OpenId Connect (OIDC) para solicitar una autorización a partir de una autenticación. En ese supuesto, puede aparecer un JWT extra donde encontraremos la información sobre el perfil del usuario.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La aplicación debe garantizar que el access token no sea accesible para otras aplicaciones en el mismo dispositivo. El token de acceso solo se puede usar a través de una conexión HTTPS, ya que pasarlo a través de un canal no encriptado haría que sea trivial para terceros interceptarlo.&lt;/p&gt;

&lt;p&gt;Una vez visto el protocolo de comunicación y alguno de los contenidos específicos que define el framework, es posible profundizar en todos los pasos que se dan durante un &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;./oauth2-codigo-autorizacion&quot;&gt;flujo de comunicación con Código de Autorización&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Photo by &lt;a href=&quot;https://unsplash.com/@karinavitvitska&quot;&gt;Karina Vitvitska&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/&quot;&gt;Unsplash&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://es.wikipedia.org/wiki/OAuth&quot;&gt;OAuth - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ionos.es/digitalguide/servidores/seguridad/oauth-y-su-version-oauth2/&quot;&gt;IONOS Digital Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.paradigmadigital.com/dev/oauth-2-0-equilibrio-y-usabilidad-en-la-securizacion-de-apis/&quot;&gt;Paradigma Digital&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/una-introduccion-a-oauth-2-es&quot;&gt;Una introducción a OAuth2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oauth.com/oauth2-servers/access-tokens/&quot;&gt;Access Tokens&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.returngis.net/2019/04/oauth-2-0-openid-connect-y-json-web-tokens-jwt-que-es-que/&quot;&gt;OAuth 2.0, OpenID Connect y JSON Web Tokens (JWT) ¿Qué es qué?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programacionymas.com/blog/protocolo-oauth-2&quot;&gt;Explicación del protocolo OAuth 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmerclick.com/article/31691178110/&quot;&gt;Principio de autenticación y autorización OAuth2.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E39820_01/doc.11121/gateway_docs/content/oauth_flows.html&quot;&gt;API Gateway OAuth 2.0 Authentication Flows&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.techgeeknext.com/spring-boot-security/oauth2-introduction&quot;&gt;OAuth 2 Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a&quot;&gt;The Complete Guide to OAuth 2.0 and OpenID Connect Protocols&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.developerro.com/2019/03/19/oauth-authentication-grant-types/&quot;&gt;OAuth 2.0 Grant Types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/es/docs/Web/HTTP/Overview&quot;&gt;Generalidades del protocolo HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Apr 2022 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/oauth2-codigo-autorizacion</link>
        <guid isPermaLink="true">http://localhost:4000/oauth2-codigo-autorizacion</guid>
        
        <category>Seguridad</category>
        
        <category>Identidad Digital</category>
        
        <category>Autorización</category>
        
        <category>OAuth2</category>
        
        <category>OAuth</category>
        
        
      </item>
    
      <item>
        <title>OAuth 2.0: Protocolo y contenido</title>
        <description>&lt;p&gt;En el anterior post &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;./oauth2&quot;&gt;Autorización a Recursos: OAuth 2.0&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; se realizó una primera aproximación conceptual
a OAuth2. En este segundo post, el objetivo es introducir algunos elementos más, que quedaron pendientes, así como
profundizar a nivel técnico en el flujo más habitual de los Grant Types, el Código de Autorización&lt;/p&gt;

&lt;h2 id=&quot;protocolo-de-comunicación&quot;&gt;Protocolo de Comunicación&lt;/h2&gt;

&lt;p&gt;Además de los actores y el flujo conversacional, para entender bien todos los pasos que se dan desde la petición de
autorización inicial, hasta la obtención de la información por parte del cliente, hay que conocer tanto el protocolo que
se utiliza para transmitir la información como su intérprete.&lt;/p&gt;

&lt;p&gt;OAuth2 es un framework pensado ser implementado mediante protocolo de comunicación HTTP, basado en el principio de
cliente-servidor, en el que las peticiones son enviadas por una entidad: el agente del usuario (o un proxy a petición de
uno). La
mayoría de las veces el agente del usuario es un navegador Web, pero podría ser cualquier otro programa.&lt;/p&gt;

&lt;p&gt;El intérprete es el elemento que articula la comunicación entre todos los actores, Usuario - Aplicación Cliente, Usuario&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Servidor de autorización, y en menor medida Aplicación Cliente - Servidor de Recursos. En este último caso,
intervienen en las redirecciones HTTP.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aunque también importante, no se va a profundizar en la estructura de la petición y respuesta HTTP por considerar que
queda fuera del alcance de artículo, aunque se puede encontrar una descripción detallada
en &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/es/docs/Web/HTTP/Overview&quot;&gt;Generalidades del protocolo HTTP&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;registro-de-la-aplicación-cliente&quot;&gt;Registro de la Aplicación Cliente&lt;/h2&gt;

&lt;p&gt;Un paso importante que no se suele mencionar al explicar el flujo abstracto o flujo lógico de OAuth2, es el registro de
la Aplicación Cliente en el Servidor de Autorización. Antes de que la Aplicación Cliente esté en condiciones de
solicitar la autorización al Usuario y comunicarse con el Servidor de Autorizaciones, es necesario que este último la
tenga registrada como una aplicación de confianza. Generalmente, esto se hace a través de un formulario de registro en
la sección de “desarrolladores” o “API” del sitio web del Servidor de Recursos.&lt;/p&gt;

&lt;p&gt;Uno de los datos que será necesario proporcionar, es la URI a la que el Servidor de Autorización deber redireccionar una
vez que el usuario haya dado su autorización. En consecuencia, será un endpoint de la Aplicación Cliente en el que
manejarán códigos de
autorización o tokens de acceso.&lt;/p&gt;

&lt;p&gt;Durante el proceso de registro, el Servidor de Autorizaciones, proporcionará al Cliente un identificador (CLIENT_ID), y
un secreto (SECRET). El primero, es una cadena pública que identifica a la Aplicación Cliente, y el segundo se utiliza
para verificar la identidad del Cliente, por lo que debe estar protegido de posibles ataques para evitar suplantaciones
de identidad.&lt;/p&gt;

&lt;h2 id=&quot;token-de-acceso&quot;&gt;Token de acceso&lt;/h2&gt;

&lt;p&gt;Es el elemento que otorga el Servidor de Autorización a la Aplicación Cliente para realizar solicitudes en nombre del
usuario. Se utilizará en la comunicación entre el Servidor de Recursos y la Aplicación Cliente para verificar los
privilegios de acceso, la autorización.&lt;/p&gt;

&lt;p&gt;Los tokens de acceso no tienen por qué tener un formato determinado. Pueden ser Bearer Tokens (al portador) o
Sender-constrained (restringidos al emisor). Los tokens restringidos al emisor requieren que el cliente de OAuth
demuestre la posesión de una clave privada para poder utilizar el token de acceso, de manera que el token de acceso por
sí mismo no sería utilizable.&lt;/p&gt;

&lt;p&gt;Hay una serie de propiedades de los tokens de acceso que son fundamentales para el modelo de seguridad de OAuth:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No deben ser leídos o interpretados por el cliente OAuth. El cliente OAuth no es el destinatario del token.&lt;/li&gt;
  &lt;li&gt;No transmiten al cliente OAuth la identidad del usuario ni ninguna otra información sobre el mismo.&lt;/li&gt;
  &lt;li&gt;Solo deben utilizarse para realizar solicitudes al servidor de recursos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Existen distintos tipos de token que se aplican en diferentes escenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Access Token&lt;/li&gt;
  &lt;li&gt;ID Token&lt;/li&gt;
  &lt;li&gt;Refresh Token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los tokens de acceso se definen en OAuth, los tokens de identificación se definen en OpenID Connect.&lt;/p&gt;

&lt;p&gt;Los tokens de acceso son lo que el cliente de OAuth utiliza para hacer peticiones a una API. El token de acceso está
destinado a ser validado por la API. Un token de identificación contiene información sobre lo que sucedió cuando un
usuario se autenticó, y está destinado a ser leído por el cliente de OAuth. El token de identificación también puede
contener información sobre el usuario, como su nombre o dirección de correo electrónico, aunque esto no es un requisito
de un token de identificación.&lt;/p&gt;

&lt;p&gt;Aquí hay algunas otras diferencias entre los tokens de identificación y los tokens de acceso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Los tokens de identificación están pensados para ser leídos por el cliente OAuth. Los tokens de acceso están
destinados a ser leídos por el servidor de recursos.&lt;/li&gt;
  &lt;li&gt;Los tokens de identificación son JWTs. Los tokens de acceso pueden ser JWTs pero también pueden ser una cadena
aleatoria.&lt;/li&gt;
  &lt;li&gt;Los tokens de identificación nunca deben ser enviados a una API. Los tokens de acceso nunca deben ser leídos por el
cliente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por otro lado, un Refresh Token en OAuth2 es una cadena que el cliente de OAuth puede utilizar para obtener un nuevo
token de acceso sin la interacción del usuario. No debe permitir al cliente obtener ningún acceso más allá del alcance
de la concesión original. Existe para permitir a los servidores de autorización utilizar tiempos de vida cortos para los
tokens de acceso sin necesidad de involucrar al usuario cuando el token expira.&lt;/p&gt;

&lt;h2 id=&quot;scopes&quot;&gt;Scopes&lt;/h2&gt;

&lt;p&gt;Los &lt;strong&gt;&lt;em&gt;scopes&lt;/em&gt;&lt;/strong&gt; en OAuth2 se utilizan para identificar los recursos a los que puede tener acceso la Aplicación Cliente.
Cuando el cliente solicita la autorización al Servidor de Autorización, envía la lista de ámbitos para los que se
solicita. El Servidor de Autorizaciones utiliza esta lista de ámbitos para generar la pantalla de consentimiento que
presentará al usuario durante el proceso de Autorización. Si el usuario acepta, el Servidor de Autorización emite un
token con el código de autorización.&lt;/p&gt;

&lt;h2 id=&quot;respuesta-oauth&quot;&gt;Respuesta OAuth&lt;/h2&gt;

&lt;p&gt;La respuesta de todos los Grant Types producen un formato de salida semejante, una estructura JSON con los siguientes
valores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;access_token&lt;/em&gt;&lt;/strong&gt; (requerido) Cadena cifrada que se utilizará posteriormente para autorizar las peticiones.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;token_type&lt;/em&gt;&lt;/strong&gt; (requerido) Identifica el tipo de token, se suele utilizar el tipo “Bearer”.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;expires_in&lt;/em&gt;&lt;/strong&gt; (recomendado) Indica la duración en segundos del access_token. Una vez caduca puede ser renovado
usando el Grant Type de Refresh Token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;refresh_token&lt;/em&gt;&lt;/strong&gt; (opcional) Permiten volver a generar el un token de acceso. Se solicitará su valor durante el
proceso de Refresh Token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;scope&lt;/em&gt;&lt;/strong&gt; (opcional) Indica el ámbito de uso del access token. La AC solicitará información de un scope concreto
durante la obtención del token.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;id_token&lt;/em&gt;&lt;/strong&gt; (opcional) Si se utiliza un scope con valor “openid”, puede significar que se quiere utilizar OpenId
Connect (OIDC) para solicitar una autorización a partir de una autenticación. En ese supuesto, puede aparecer un JWT
extra donde encontraremos la información sobre el perfil del usuario.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La aplicación debe garantizar que el access token no sea accesible para otras aplicaciones en el mismo dispositivo. El
token de acceso solo se puede usar a través de una conexión HTTPS, ya que pasarlo a través de un canal no encriptado
haría que sea trivial para terceros interceptarlo.&lt;/p&gt;

&lt;p&gt;Una vez visto el protocolo de comunicación y alguno de los contenidos específicos que define el framework, es posible
profundizar en todos los pasos que se dan durante
un &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;./oauth2-codigo-autorizacion&quot;&gt;flujo de comunicación con Código de Autorización&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Photo by &lt;a href=&quot;https://unsplash.com/@yannikm&quot;&gt;Yannik Mika&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/&quot;&gt;Unsplash&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://es.wikipedia.org/wiki/OAuth&quot;&gt;OAuth - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ionos.es/digitalguide/servidores/seguridad/oauth-y-su-version-oauth2/&quot;&gt;IONOS Digital Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.paradigmadigital.com/dev/oauth-2-0-equilibrio-y-usabilidad-en-la-securizacion-de-apis/&quot;&gt;Paradigma Digital&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/una-introduccion-a-oauth-2-es&quot;&gt;Una introducción a OAuth2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oauth.com/oauth2-servers/access-tokens/&quot;&gt;Access Tokens&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.returngis.net/2019/04/oauth-2-0-openid-connect-y-json-web-tokens-jwt-que-es-que/&quot;&gt;OAuth 2.0, OpenID Connect y JSON Web Tokens (JWT) ¿Qué es qué?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programacionymas.com/blog/protocolo-oauth-2&quot;&gt;Explicación del protocolo OAuth 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmerclick.com/article/31691178110/&quot;&gt;Principio de autenticación y autorización OAuth2.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E39820_01/doc.11121/gateway_docs/content/oauth_flows.html&quot;&gt;API Gateway OAuth 2.0 Authentication Flows&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.techgeeknext.com/spring-boot-security/oauth2-introduction&quot;&gt;OAuth 2 Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a&quot;&gt;The Complete Guide to OAuth 2.0 and OpenID Connect Protocols&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.developerro.com/2019/03/19/oauth-authentication-grant-types/&quot;&gt;OAuth 2.0 Grant Types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/es/docs/Web/HTTP/Overview&quot;&gt;Generalidades del protocolo HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 14 Apr 2022 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/oauth2-protocolo</link>
        <guid isPermaLink="true">http://localhost:4000/oauth2-protocolo</guid>
        
        <category>Seguridad</category>
        
        <category>Identidad Digital</category>
        
        <category>Autorización</category>
        
        <category>OAuth2</category>
        
        <category>OAuth</category>
        
        
      </item>
    
      <item>
        <title>Autorización de Recursos: OAuth 2.0</title>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;Open Authorization 2.0 (OAuth2)&lt;/em&gt;&lt;/strong&gt; es un estándar diseñado para permitir que una aplicación acceda a recursos alojados por otras aplicaciones web en nombre de un usuario. Sustituyó a OAuth 1.0 en 2012 y es ahora el estándar de facto de la industria para la autorización en línea.&lt;/p&gt;

&lt;p&gt;OAuth 2.0 proporciona acceso consentido y restringe las acciones que la aplicación cliente puede realizar en los recursos en nombre del usuario, sin compartir nunca las credenciales de este, desacoplando autenticación de autorización&lt;/p&gt;

&lt;p&gt;Aunque la web es la principal plataforma de OAuth 2, la especificación también describe cómo gestionar este tipo de acceso delegado a otros tipos de clientes (aplicaciones basadas en el navegador, aplicaciones web del lado del servidor, aplicaciones nativas/móviles, dispositivos conectados, etc.)&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Un buen ejemplo que explica el funcionamiento del framework, es el que utiliza &lt;a href=&quot;https://www.paradigmadigital.com/dev/oauth-2-0-equilibrio-y-usabilidad-en-la-securizacion-de-apis/&quot;&gt;Paradigma Digital&lt;/a&gt; en su blog:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“De una manera simplificada, el uso de OAuth es análogo al uso de una tarjeta de acceso a un hotel.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Para obtener la tarjeta de acceso, el primer paso es pasar un proceso de autenticación tras el cual te dan la tarjeta (un access token), posteriormente puedes usar la tarjeta para acceder a los distintos partes del hotel (recursos de la API) a las cuales se tiene permiso para acceder o no dependiendo de la autorización.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Dada la complejidad que puede llegar a tener una comunicación OAuth2, su explicación se va a dividir en tres post, este primero en el que se abordarán los conceptos fundamentales y flujo funcional, un segundo post en el que se profundizará en otros elementos relacionados con el protocolo de comunicación, y un tercero en el que se explicará a bajo nivel el flujo de comunicación OAuth2 más habitual.&lt;/p&gt;

&lt;p&gt;La estructura será:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Post 1
    &lt;ul&gt;
      &lt;li&gt;Actores&lt;/li&gt;
      &lt;li&gt;Tipos de autorización&lt;/li&gt;
      &lt;li&gt;Flujo lógico&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Post 2
    &lt;ul&gt;
      &lt;li&gt;Protocolo&lt;/li&gt;
      &lt;li&gt;Registro de la aplicación cliente&lt;/li&gt;
      &lt;li&gt;Token de acceso&lt;/li&gt;
      &lt;li&gt;Respuesta OAuth&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Post 3
    &lt;ul&gt;
      &lt;li&gt;Código de Autorización: Diagrama de secuencia&lt;/li&gt;
      &lt;li&gt;Código de Autorización: Cabeceras HTTP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-actores&quot;&gt;1. Actores&lt;/h2&gt;

&lt;p&gt;Los actores que intervienen en una operación OAuth 2.0 son cuatro:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Propietario del Recurso &lt;strong&gt;&lt;em&gt;(PR)&lt;/em&gt;&lt;/strong&gt; o Usuario &lt;strong&gt;&lt;em&gt;(U)&lt;/em&gt;&lt;/strong&gt; de la Aplicación Cliente. Se utilizará indistintamente un término u otro.&lt;/li&gt;
  &lt;li&gt;Servidor de Autorización &lt;strong&gt;&lt;em&gt;(SA)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Servidor de Recursos &lt;strong&gt;&lt;em&gt;(SR)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Aplicación Cliente &lt;strong&gt;&lt;em&gt;(AC)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;propietario-del-recurso&quot;&gt;Propietario del Recurso&lt;/h3&gt;

&lt;p&gt;Es el usuario de la Aplicación Cliente, que a la vez posee una cuenta en el Servidor de Recursos, de la que se va compartir información con la Aplicación Cliente.&lt;/p&gt;

&lt;h3 id=&quot;servidor-de-autorización&quot;&gt;Servidor de Autorización&lt;/h3&gt;

&lt;p&gt;Es responsable del proceso de autenticación para verificar la identidad del Propietario del Recurso, y de la Aplicación Cliente. Emite tokens de acceso a la Aplicación Cliente  que autorizan el acceso a la información del Propietario del Recurso en el Servidor de Recursos.&lt;/p&gt;

&lt;h3 id=&quot;servidor-de-recursos&quot;&gt;Servidor de Recursos&lt;/h3&gt;

&lt;p&gt;Aloja las cuentas de usuario. En general desde el punto de vista de la comunicación entre cliente y proveedor, no suele existir diferencia entre Servidor de Autorización y Servidor de Recursos. El cliente se comunica de forma transparente mediante protocolo HTTP con ambos sin conocer cuál es cuál, ya que muchas compañías implementan un servidor que desempeña ambos roles.&lt;/p&gt;

&lt;h3 id=&quot;aplicación-cliente&quot;&gt;Aplicación cliente&lt;/h3&gt;

&lt;p&gt;Es la aplicación que desea acceder a la información de la cuenta del usuario en el Servidor de Recursos. Antes de poder hacerlo debe ser autorizada por el usuario, y por el Servidor de Autorización.&lt;/p&gt;

&lt;p&gt;Además OAuth2 distingue entre Aplicaciones Cliente confidenciales y públicas. Las primeras son capaces de guardar una contraseña sin que esta sea expuesta, y las segundas no.&lt;/p&gt;

&lt;h2 id=&quot;2-tipos-de-autorización-grant-types&quot;&gt;2. Tipos de autorización (Grant Types)&lt;/h2&gt;

&lt;p&gt;Los tipos de autorización se corresponden con el grado de confianza entre Servidor de Recursos, la Aplicación Cliente, y el tipo de contenido. Dependiendo del tipo de autorización la secuencia de comunicación entre los actores varía. Los principales tipos de autorización son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Código de autorización&lt;/strong&gt;: Se necesita la interacción entre Propietario del Recurso, Aplicación Cliente y Servidor de Autorización, para obtener una autorización de acceso al Servidor de Recursos.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Autorización implícita&lt;/strong&gt;: Es un flujo diseñado para aplicaciones que no pueden guardar de forma segura las credenciales que la identifican en el Servidor de Recursos.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Credenciales de Propietario del Recurso&lt;/strong&gt;: El Propietario del Recurso confía sus credenciales de acceso a la Aplicación Cliente. Este flujo impide la gestión de niveles de autorización, la Aplicación Cliente podrá acceder a todos los recursos del usuario.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Credenciales de cliente&lt;/strong&gt;: Se utiliza cuando una Aplicación Cliente quiere acceder a datos que no tienen propietario o no requieren autorización.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-flujo-lógico&quot;&gt;3. Flujo lógico&lt;/h2&gt;

&lt;p&gt;Una vez entendida la finalidad del framework y los actores implicados, el siguiente paso es describir las relaciones que se dan entre ellos. La secuencia de acciones que se da hasta que la Aplicación Cliente obtiene el recurso en el Servidor de Recursos es:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;El usuario accede a la Aplicación Cliente. Ésta para proporcionar servicio necesita acceder a la información del usuario en el Servidor de Recursos.&lt;/li&gt;
  &lt;li&gt;La Aplicación Cliente solicita autorización al Usuario para acceder a su cuenta en el Servidor de Recursos.&lt;/li&gt;
  &lt;li&gt;El Usuario concede la autorización.&lt;/li&gt;
  &lt;li&gt;La Aplicación Cliente con la autorización concedida por el Propietario del Recurso, solicita un identificador de acceso al Servidor de Autorización.&lt;/li&gt;
  &lt;li&gt;El Servidor de Autorización proporciona credenciales de acceso a la Aplicación Cliente mediante un Access Token. La fase de autorización es completada.&lt;/li&gt;
  &lt;li&gt;La Aplicación Cliente presenta el access token al Servidor de Recursos&lt;/li&gt;
  &lt;li&gt;El Servidor de Recursos pregunta al Servidor de Autorización por la validez del token recibido&lt;/li&gt;
  &lt;li&gt;Si el access token es válido el Servidor de Recursos, entrega la información solicitada a la Aplicación Cliente.&lt;/li&gt;
&lt;/ol&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2022/20220402-oauth2/oauth-flow.jpg#wide&quot; alt=&quot;Flujo Oauth&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; -webkit-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!-- -moz-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;Flujo OAuth&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/posts/2022/20220402-oauth2/oauth-flow.jpg#wide&quot; alt=&quot;Flujo Oauth&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; border-radius: 10px;
box-shadow: 0 0 15px #ddd;&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;Flujo OAuth&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2022/20220402-oauth2/oauth-flow.jpg#wide&quot; alt=&quot;Flujo Oauth&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center;&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;Flujo OAuth&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;p&gt;El flujo anterior, aunque válido para entender las implicaciones a nivel funcional, desde el punto de vista técnico es incompleto, ya que, no se menciona nada sobre el protocolo, agente de comunicación, ámbitos (scopes) a los que puede tener acceso el Cliente, o condiciones de registro de la Aplicación Cliente.&lt;/p&gt;

&lt;p&gt;En las próximas entradas se profundizará paulatinamente en el resto de elementos, hasta llegar a las cabeceras de las peticiones y respuestas HTTP: &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;./oauth2-protocolo&quot;&gt;OAuth 2.0: Protocolo y contenido &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Photo by &lt;a href=&quot;https://unsplash.com/@gregbulla?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Greg Bulla&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/&quot;&gt;Unsplash&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://es.wikipedia.org/wiki/OAuth&quot;&gt;OAuth - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ionos.es/digitalguide/servidores/seguridad/oauth-y-su-version-oauth2/&quot;&gt;IONOS Digital Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.paradigmadigital.com/dev/oauth-2-0-equilibrio-y-usabilidad-en-la-securizacion-de-apis/&quot;&gt;Paradigma Digital&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/una-introduccion-a-oauth-2-es&quot;&gt;Una introducción a OAuth2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oauth.com/oauth2-servers/access-tokens/&quot;&gt;Access Tokens&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.returngis.net/2019/04/oauth-2-0-openid-connect-y-json-web-tokens-jwt-que-es-que/&quot;&gt;OAuth 2.0, OpenID Connect y JSON Web Tokens (JWT) ¿Qué es qué?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programacionymas.com/blog/protocolo-oauth-2&quot;&gt;Explicación del protocolo OAuth 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmerclick.com/article/31691178110/&quot;&gt;Principio de autenticación y autorización OAuth2.0&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E39820_01/doc.11121/gateway_docs/content/oauth_flows.html&quot;&gt;API Gateway OAuth 2.0 Authentication Flows&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.techgeeknext.com/spring-boot-security/oauth2-introduction&quot;&gt;OAuth 2 Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a&quot;&gt;The Complete Guide to OAuth 2.0 and OpenID Connect Protocols&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.developerro.com/2019/03/19/oauth-authentication-grant-types/&quot;&gt;OAuth 2.0 Grant Types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://auth0.com/intro-to-iam/what-is-oauth-2/&quot;&gt;Auth0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 02 Apr 2022 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/oauth2</link>
        <guid isPermaLink="true">http://localhost:4000/oauth2</guid>
        
        <category>Seguridad</category>
        
        <category>Identidad Digital</category>
        
        <category>Autorización</category>
        
        <category>OAuth2</category>
        
        <category>OAuth</category>
        
        
      </item>
    
      <item>
        <title>IdM - Gestión Identidad Digital</title>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;IdM (Identity Management)&lt;/em&gt;&lt;/strong&gt; por sus siglas en inglés, o también &lt;strong&gt;&lt;em&gt;Gestión de Identidades y Accesos (IAM/IdAM Identity Access Management)&lt;/em&gt;&lt;/strong&gt; , es el marco de políticas y tecnologías que garantiza que solamente las personas autorizadas, y nadie más, tengan acceso a los recursos tecnológicos que necesitan para realizar su trabajo.&lt;/p&gt;

&lt;p&gt;Esta gestión evita el acceso no autorizado a sistemas y recursos, ayuda a evitar el robo de datos, y genera alertas cuando personas o programas no autorizados intentan acceder a éstos. Pero las soluciones de gestión de identidades, no solo protegen el acceso al software y a los datos, también protegen los recursos hardware, redes, servidores, dispositivos de almacenamiento, etc.&lt;/p&gt;

&lt;p&gt;Aunque IdM e IdAM son términos que se utilizan indistintamente, la gestión de identidades se centra más en la identidad de los usuarios, sus roles, grupos a los que pertenece, y en consecuencia a sus permisos.  Mientras que IdM también se centra en proteger las identidades a través de tecnologias tales como contraseñas, biometrías, o identidades digitales.&lt;/p&gt;

&lt;h2 id=&quot;gestión-de-identidades-vs-gestión-de-acceso&quot;&gt;Gestión de identidades vs Gestión de acceso&lt;/h2&gt;

&lt;h3 id=&quot;gestión-de-identidades&quot;&gt;Gestión de identidades&lt;/h3&gt;

&lt;p&gt;Desde el punto de vista de las organizaciones, la identidad digital hace referencia a la información que permite identificar univocamente a la persona física y su atributos asociados tales como: información de contacto, posición en la empresa, rol, etc.. La gestión de identidad es el conjunto de procesos y tecnologías para la captura, registro, gestión de los usuarios y sus atributos en la organización, así como el seguimiento de los mismos y control de cambios. Esto asegura que los usuarios están debidamente autenticados, autorizados y auditados, según normativa y de acuerdo a la política organizacional.&lt;/p&gt;

&lt;h3 id=&quot;gestión-de-acceso&quot;&gt;Gestión de acceso&lt;/h3&gt;

&lt;p&gt;Es otorgar a un usuario el derecho de acceso a un servicio, al mismo tiempo que se previene el acceso a usuarios no autorizados. Los procesos de Gestión de Acceso ponen en práctica las políticas definidas por la Gestión de Seguridad.&lt;/p&gt;

&lt;p&gt;Para verificar la identidad, un sistema informático buscará características específicas del usuario, habitualmente conocidas como &lt;em&gt;factores de autenticación&lt;/em&gt;. Los tres más utilizados son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Algo que sabe el usuario. Se trata de una información que debe tener el usuario, como su user/password.&lt;/li&gt;
  &lt;li&gt;Algo que tiene el usuario. En este caso, se trata de un objeto físico otorgado a los usuarios autorizados, como usb, teléfono inteligente, etc.&lt;/li&gt;
  &lt;li&gt;Algo que el usuario es. Hace referencia a alguna propiedad física del propio cuerpo, como la cara o la huella dactilar.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;computación-en-la-nube-e-idam&quot;&gt;Computación en la nube e IdAM&lt;/h2&gt;

&lt;p&gt;Hasta hace poco, antes de la adopción generalizada de la computación en la nube, los sistemas que había que burlar para acceder a información confidencial se basaban en el perímetro de red de la empresa. Así, antes había que superar el firewall corporativo que protegía la red interna o acceder físicamente al servidor en el que se encontrase la información.&lt;/p&gt;

&lt;p&gt;Sin embargo, con la computación en la nube la información se almacena en servidores remotos fuera del perímetro de red corporativo. De forma que para acceder a la información confidencial, es necesario iniciar sesión mediante un navegador o una aplicación. Así que la forma más rápida de obtener esta información ilícitamente es hacerse con las credenciales de inicio de un usuario autorizado.&lt;/p&gt;

&lt;p&gt;Es en este ámbito en el que la Gestión de identidades y accesos ayuda a prevenir ataques basados en identidad y fugas de datos debidos a usuarios no autorizados con demasiados privilegios (escalada de privilegios)&lt;/p&gt;

&lt;h2 id=&quot;fuentes&quot;&gt;Fuentes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vmware.com/es/topics/glossary/content/identity-management.html&quot;&gt;VMware - Gestión de identidades&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Identity_management&quot;&gt;Wikipedia - Identity management&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.computerweekly.com/es/definicion/IAM-o-Sistema-de-gestion-de-accesos-e-identidades&quot;&gt;Computer Weekly - IAM o Sistema de gestión de accesos e identidades&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.es.it-processmaps.com/index.php/ITIL_Gestion_del_Acceso&quot;&gt;ITIL Gestión del Acceso&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Photo by &lt;a href=&quot;https://unsplash.com/@carsonarias?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Carson Arias&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/identity?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/es-es/learning/access-management/what-is-identity-and-access-management/&quot;&gt;CloudFlare - ¿Qué es la gestión de identidad y acceso?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 06 Nov 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/gestion-identidad-digital</link>
        <guid isPermaLink="true">http://localhost:4000/gestion-identidad-digital</guid>
        
        <category>Seguridad</category>
        
        <category>Identidad Digital</category>
        
        <category>Transformación Digital</category>
        
        
      </item>
    
      <item>
        <title>RBAC - Role based access Control</title>
        <description>&lt;p&gt;El control de acceso basado en roles es un paradigma de seguridad que permite controlar las acciones que los usuarios de un sistema/organización pueden realizar sobre los recursos del mismo, en función de los privilegios por rol. Se basa en una estructura de tres niveles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;usuarios&lt;/li&gt;
  &lt;li&gt;roles&lt;/li&gt;
  &lt;li&gt;grupos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tiene como objetivo asegurar la confidencialidad, integridad y disponibilidad de la información.&lt;/p&gt;

&lt;p&gt;Normalmente empresas y organizaciones, quieren proteger sus datos de accesos y cambios no autorizados. Tradicionalmente para garantizar la seguridad, las el control de acceso se gestionaba de forma individual mediante &lt;em&gt;listas de control de acceso&lt;/em&gt; (ACL - access control list). El problema de este tipo de mecanismo de control es que tanto el coste de mantenimiento, como el número de errores de gestión, aumentan a medida que aumenta el número de usuarios a gestionar.&lt;/p&gt;

&lt;p&gt;Sin embargo RBAC es un modelo en el que se puede aplicar una política de seguridad a un nivel más específico, mediante el &lt;strong&gt;&lt;em&gt;principio de seguridad del privilegio mínimo&lt;/em&gt;&lt;/strong&gt;. Este principio se basa en la idea de que un usuario debe disponer de los privilegios mínimos necesarios para realizar su trabajo. Los roles abstraen los procesos del trabajo de una organización, pueden variar entre organizaciones, y pueden referirse a aspectos diversos como departamentos, ubicaciones, centros, o funciones de los empleados.&lt;/p&gt;

&lt;p&gt;Los roles deben estar orientados a la estructura organizativa de la empresa. Se deben identificar todas las autorizaciones que cada empleado de la organización necesita, tales como acceso a internet, aplicaciones, recursos de red, o inicio de sesión.&lt;/p&gt;

&lt;h2 id=&quot;implementación&quot;&gt;Implementación&lt;/h2&gt;

&lt;p&gt;Lo primero que debe hacerse al implementar un mecanismo RBAC es determinar qué funciones se van a desempeñar en cada puesto o departamento, para en base a ellas, identificar las herramientas y/o recursos que se necesitan para llevarlas a cabo.&lt;/p&gt;

&lt;p&gt;En segundo lugar se procederá a la asignación de roles, donde habrá que que tener en cuenta que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;los roles se asignan a los empleados según sus tareas o puesto en la empresa&lt;/li&gt;
  &lt;li&gt;se puede asignar uno o más roles por usuario&lt;/li&gt;
  &lt;li&gt;Se pueden combinar los privilegios por rol con la asignación de privilegios de forma individual.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por último, será necesario identificar el &lt;strong&gt;&lt;em&gt;Ámbito&lt;/em&gt;&lt;/strong&gt; al que se aplica el control de acceso, entendiendo por ámbito el conjunto de recursos. Los más habituales incluyen:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Derechos a los datos (read, read and write, full access)&lt;/li&gt;
  &lt;li&gt;Derechos de acceso a aplicaciones&lt;/li&gt;
  &lt;li&gt;Autorización de solicitudes&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
 &lt;img class=&quot;image-center&quot; src=&quot;/assets/images/posts/2021/20211105rbac/20211105model-image.png&quot; alt=&quot;modelo entidad-relación RBAC&quot; /&gt;
&lt;figcaption class=&quot;figure-caption&quot;&gt;modelo entidad-relación RBAC&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;asignación-de-permisos&quot;&gt;Asignación de permisos&lt;/h3&gt;

&lt;p&gt;La asignación de permisos, se realiza a tres niveles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se deben identificar las autorizaciones que necesitan los individuos que pertenecen a un mismo &lt;strong&gt;&lt;em&gt;grupo de trabajo&lt;/em&gt;&lt;/strong&gt;, como es el caso de un &lt;strong&gt;&lt;em&gt;departamento&lt;/em&gt;&lt;/strong&gt;. Las autorizaciones correspondientes se asignan a todos los empleados de cada departamento.&lt;/li&gt;
  &lt;li&gt;A otro nivel de abstracción, es necesario definir funciones de un puesto y sus tareas implicadas, que pueden corresponder a un subconjunto dentro del departamento, o a un rol desempeñado de forma individual.&lt;/li&gt;
  &lt;li&gt;Por último es posible asignar a cada empleado los roles adicionales que necesite&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;modelos&quot;&gt;Modelos&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC plano&lt;/em&gt;&lt;/strong&gt;. Es el modelo base.
    &lt;ul&gt;
      &lt;li&gt;A los usuarios se les asignan roles que tienen asignados privilegios, de forma que a través de un rol, los usuarios adquieren permisos.&lt;/li&gt;
      &lt;li&gt;Requiere que el usuario-rol y el permiso-rol se pueda asignar de muchos a muchos
        &lt;ul&gt;
          &lt;li&gt;Un usuario puede ser asignado a muchos roles&lt;/li&gt;
          &lt;li&gt;Un rol puede ser asignado a muchos usuarios&lt;/li&gt;
          &lt;li&gt;Un permiso puede ser asignado a muchos roles&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;Implica la revisión del rol de los usuarios&lt;/em&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC jerárquico&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Incluye las características del RBAC Plano, pero además los roles se organizan por jerarquías
        &lt;ul&gt;
          &lt;li&gt;Los roles superiores contienen los permisos de los roles inferiores&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Deja la definición de jerarquías abierta, para que cada organización define la suya.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC restringido&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Tiene en cuenta la separación de funciones, como un sistema creado para minimizar la comisión de actos fraudulentos. Se basa en la necesidad de implicar a más de un miembro o empleado para completar una tarea.&lt;/li&gt;
      &lt;li&gt;Determinados accesos y acciones requieren de los permisos de más de un rol&lt;/li&gt;
      &lt;li&gt;Puede ser estático o dinámico (implica activación de roles)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC simétrico&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Implica que se puedan revisar y ajustar los roles y permisos de cada función de forma periódica, para poder adaptarse a los cambios de forma efectiva.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ventajas&quot;&gt;Ventajas&lt;/h2&gt;

&lt;p&gt;Entre las principales ventajas de RBAC destacan:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Flexibilidad&lt;/em&gt;&lt;/strong&gt;. Los cambios en la estructura organizativa o autorizaciones se pueden modificar rápidamente.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Administración&lt;/em&gt;&lt;/strong&gt;. Su administración es mucho menos costosa que la gestión de permisos individuales, y se cometen muchos menos errores en su gestión&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Eficiencia&lt;/em&gt;&lt;/strong&gt;. Gracias a la mejora en la administración el proceso es más eficiente, pudiendo automatizarse y disminuyendo los tiempos de espera.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Seguridad&lt;/em&gt;&lt;/strong&gt;. Aumenta la seguridad gracias al &lt;strong&gt;&lt;em&gt;Principio del Menor Privilegio&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Transparencia&lt;/em&gt;&lt;/strong&gt;. Al estar basada en roles, la administración se simplifica, y es más fácil de entender la política aplicada.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;p&gt;Sin embargo, la adopción de este sistema de control de accesos conlleva una serie de inconvenientes a tener en cuenta:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Elaboración&lt;/em&gt;&lt;/strong&gt;. Transferir la estructura organizativa a un modelo de control de accesos es laborioso.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Conveniencia&lt;/em&gt;&lt;/strong&gt;. Para modelos organizativos pequeños, la asignación de permisos individuales puede ser más ágil.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fuentes&quot;&gt;Fuentes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E24842_01/html/E23286/rbac-1.html&quot;&gt;Oracle. Guía de administración del sistema: servicios de seguridad&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ionos.es/digitalguide/servidores/seguridad/que-es-el-role-based-access-control-rbac/&quot;&gt;Ionos Digital Guide. Role based access control (RBAC): ¿Cómo funciona el control de acceso basado en roles?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.manageengine.com/es/device-control/role-based-access-control.html&quot;&gt;Manage Engine. Prevenga los ataques basados en archivos con un control de acceso efectivo basado en roles&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://protecciondatos-lopd.com/empresas/control-de-acceso-basado-en-roles-rbac/&quot;&gt;Ático 34. Control de acceso basado en roles (RBAC): Una forma de mejorar la seguridad del sistema&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rawpixel.com&quot;&gt;Foto de Gráfico creado por rawpixel.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mysql.tutorials24x7.com/blog/guide-to-design-database-for-rbac-in-mysql&quot;&gt;Tutorials24x7. Guide To Design Database For RBAC In MySQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 05 Nov 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/role-based-access-control</link>
        <guid isPermaLink="true">http://localhost:4000/role-based-access-control</guid>
        
        <category>Seguridad</category>
        
        
      </item>
    
      <item>
        <title>Arquitectura hexagonal</title>
        <description>&lt;p&gt;Propuesta en 2005 por &lt;a href=&quot;http://web.archive.org/web/20180121161736/http://alistair.cockburn.us/Hexagonal+Architecture&quot;&gt;Alistair Cockburn&lt;/a&gt;, también conocida como arquitectura de puertos y adaptadores, su finalidad es desacoplar las capas de la aplicación, y permitir así que evolucionen de forma aislada. La forma de conseguirlo, considerar el dominio como el núcleo de la arquitectura, y proteger su estructura de interacciones con elementos externos.&lt;/p&gt;

&lt;p&gt;El motivo de representar este tipo de arquitecturas como un hexágono, es arbitrario, lo que pretende reflejar es el hecho de que las comunicaciones con el exterior tienen la misma naturaleza y deben asumir las mismas reglas.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;La consecuencia que se deriva de aplicar esta arquitectura, es desarrollar aplicaciones que son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Independientes de agentes externos&lt;/li&gt;
  &lt;li&gt;Independientes de framework&lt;/li&gt;
  &lt;li&gt;Independientes de la UI&lt;/li&gt;
  &lt;li&gt;Independientes de BBDD&lt;/li&gt;
  &lt;li&gt;Más adaptables&lt;/li&gt;
  &lt;li&gt;Más reutilizables&lt;/li&gt;
  &lt;li&gt;Más mantenibles&lt;/li&gt;
  &lt;li&gt;Más testeables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;motivación&quot;&gt;Motivación&lt;/h2&gt;

&lt;p&gt;En su origen, Alistair Cockburn hacía mucho énfasis en evitar la infiltración de la lógica de negocio en la interfaz de usuario. Ya que si esto se produce, da lugar a una arquitectura fuertemente acoplada entre el frontend y el backend.&lt;/p&gt;

&lt;p&gt;Su propuesta pretende mejorar las siguientes áreas durante el ciclo de vida del producto:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;automatización de pruebas&lt;/li&gt;
  &lt;li&gt;desacoplamiento de los detalles de infraestructura&lt;/li&gt;
  &lt;li&gt;conexión con nuevos agentes&lt;/li&gt;
  &lt;li&gt;abstraer el dominio de la comunicación con agentes externos, usuarios, comandos, lotes, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Según él, la raíz del problema está en la interacción entre el interior y el exterior, la regla es que los detalles del código interior no deben filtrarse al exterior.&lt;/p&gt;

&lt;p&gt;Para conseguirlo, propone utilizar el patrón de puertos y adaptadores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Los &lt;strong&gt;puertos&lt;/strong&gt; son las interfaces que definen la interacción con el exterior y exponen únicamente el contrato con nuestro dominio, dejando que toda la lógica de transformación esté de puertas afuera y no se contamine el interior. Pueden ser de varios tipos:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;de entrada&lt;/strong&gt;. Sirven para hacer peticiones a la aplicación&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;de salida&lt;/strong&gt;. Sirven para solicitar información desde la aplicación&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;de entrada/salida&lt;/strong&gt;. En general son adaptadores bidireccionales a un recurso. No representan comunicación bidireccional, sino que la aplicación es capaz de escuchar peticiones del recurso y hacerle peticiones.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Los &lt;strong&gt;adaptadores&lt;/strong&gt; son precisamente la forma de conectarse a través de dicho contrato. Establecen la comunicación y la conversión de datos entre el dominio y el exterior. Lo relevante en esta interacción, es que los adaptadores no pertenecen al core, así que pueden implementarse por separado. Para cada dispositivo externo habrá un adaptador, y será de entrada o salida dependiendo del sentido de la comunicación. Por lo general habrá varios adaptadores para cada tipo de puerto, uno por tipo de tecnología o agente que puede conectarse a ese puerto.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Además, diferencia entre dos tipos de puertos y adaptadores. Los &lt;strong&gt;primarios o driving&lt;/strong&gt;, son los que habilitan conexiones hacia nuestra aplicación, y los &lt;strong&gt;secundarios&lt;/strong&gt; que permiten conexiones desde nuestra aplicación. También tienen otra particularidad, en los que conectan la UI con la aplicación, el adaptador pertence a la capa de aplicación (API) del caso de uso, mientras que en el caso de backend, es éste el que inyecta el adaptador específico para permitir la comunicación con la utilidad. El núcleo en ambos casos solo debe conocer la interfaz.&lt;/p&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; -webkit-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!-- -moz-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; border-radius: 10px;
box-shadow: 0 0 15px #ddd;&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center;&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;h2 id=&quot;arquitectura-hexagonal-y-ddd&quot;&gt;Arquitectura hexagonal y DDD&lt;/h2&gt;

&lt;p&gt;Al ser el dominio el elemento en torno al cual se define este enfoque, encaja muy bien con la idea de &lt;strong&gt;Domian Driven Design&lt;/strong&gt;, ya que se puede implementar su lógica sin atender a detalles específicos.&lt;/p&gt;

&lt;p&gt;Sin embargo, un punto de vista crítico con todo este planteamiento, que considero muy interesante es el de &lt;a href=&quot;https://javiervelezreyes.com/ni-nueva-ni-arquitectura-ni-hexagonal/&quot;&gt;Javier Vélez Reyes - Ni Nueva Ni Arquitectura Ni Hexagonal&lt;/a&gt;, que argumenta razonadamente en contra de esta propuesta, como un enfoque geniunamente arquitectónico y rebajándolo a un tipo de patrón o recomendación de buenas prácticas, que símplemnte aglutina conceptos preexistentes.&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.archive.org/web/20180121161736/http://alistair.cockburn.us/Hexagonal+Architecture&quot;&gt;Alistair Cockburn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@edusalguero/arquitectura-hexagonal-59834bb44b7f&quot;&gt;Edu Slaguero: Arquitectura hexagonal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.allegro.tech/2020/05/hexagonal-architecture-by-example.html&quot;&gt;Allegro Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbertograca.com/2017/09/14/ports-adapters-architecture/&quot;&gt;hgraca&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.adictosaltrabajo.com/2019/07/02/capas-cebollas-y-colmenas-arquitecturas-en-el-backend/&quot;&gt;Capas, cebollas y colmenas: arquitecturas en el backend&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://javiervelezreyes.com/ni-nueva-ni-arquitectura-ni-hexagonal/&quot;&gt;Ni Nueva Ni Arquitectura Ni Hexagonal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/arquitectura-hexagonal</link>
        <guid isPermaLink="true">http://localhost:4000/arquitectura-hexagonal</guid>
        
        <category>Diseño</category>
        
        <category>Arquitectura</category>
        
        
      </item>
    
      <item>
        <title>Entity-Boundary-Control</title>
        <description>&lt;p&gt;Aunque la dio a conocer Robert C. Martin, fue propuesta por Ivar Jacobson en 1992. Su nombre original, Entity-Interface-Control, se cambió para evitar confusiones con conceptos similares de los lenguajes de programación. Es un patrón arquitectónico utilizado en el diseño de software orientado a objetos, en el que los casos de uso categorizan las clases que componen el software según su responsabilidad.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“La arquitectura de una aplicación se rige por sus casos de uso.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jacobson, proponía este modelo para el análisis y diseño de actividades, y su representación mediante sus estereotipos UML.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Su propósito, producir una arquitectura agnóstica a la implementación, que no esté atada a una plataforma, aplicación, lenguaje o marco específico; y cuyos elementos estén unidos por un acoplamiento lo más débil posible. Esta es su principal diferencia con MVC, ya que ni controladores ni entidades, conocen el medio por el que se está accediendo a ellas. En MVC, siempre hay una dependencia con el mecanismo de entrega.&lt;/p&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; -webkit-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!-- -moz-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; border-radius: 10px;
box-shadow: 0 0 15px #ddd;&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center;&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;p&gt;Sus responsabilidades:&lt;/p&gt;

&lt;h2 id=&quot;entity&quot;&gt;Entity&lt;/h2&gt;

&lt;p&gt;Las entidades contienen los datos utilizados por el sistema y los cálculos asociados a estos. Cada entidad representa un concepto relevante dentro del dominio del problema, y mantiene la identidad de los datos persistentes.&lt;/p&gt;

&lt;p&gt;Adicionalmente, Jacobson propone que la naturaleza de la lógica de la entidad, es tal, que si la estructura de los datos que contiene cambia, las operaciones sobre estos datos también tendrán que cambiar. Por eso deben estar ubicados juntos.&lt;/p&gt;

&lt;p&gt;Por lo tanto, al igual que defienden otros autores, esta recomendación va en contra de lo que actualmente se conoce como entidades anémicas &lt;a href=&quot;https://es.wikipedia.org/wiki/Modelo_de_dominio_an%C3%A9mico&quot;&gt;modelo anémico&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;boundary-interfaz&quot;&gt;Boundary (interfaz)&lt;/h2&gt;

&lt;p&gt;Se trata de los objetos que modelan todas las interacciones del sistema con los actores externos. Cualquier interacción del sistema con un actor, debe pasar por un objeto Boundary. Ya sea la implementación de la funcionalidad para el procesamiento de datos para una interfaz grafica de usuario o de un API web. Por lo tanto su naturaleza es funcional, aceptan solicitudes y producen respuestas como ressultado.&lt;/p&gt;

&lt;h2 id=&quot;controlador&quot;&gt;Controlador&lt;/h2&gt;

&lt;p&gt;La relevancia de este último tipo de objeto es proporcionar la comunicación entre interfaces y entidades, evitando que éstas últimas propaguen su lógica a los actores externos con los que se comunican.&lt;/p&gt;

&lt;p&gt;Los controladores, según Jacobson son aquellos que orquestan un caso de uso, así como los objetos que contengan un comportamiento relevante para éste y que no sean una entidad o una interfaz. Aceptan peticiones de o límites, deciden qué hacer con ellas y manipulan el estado de la aplicación. Por tanto conocen los modelos de petición y respuesta, &lt;a href=&quot;https://www.programmersought.com/article/9051259027/&quot;&gt;&lt;strong&gt;DTO’s&lt;/strong&gt;&lt;/a&gt;. De alguna manera son la implementación concreta de los límites.&lt;/p&gt;

&lt;h2 id=&quot;interacciones&quot;&gt;Interacciones&lt;/h2&gt;

&lt;p&gt;En cuanto a las interacciones que se pueden dar entre los tres tipos de objetos, deben ser tales, que respeten la Ley de Demeter LoD, o principio del mínimo conocimiento. Se trata de una directriz de diseño para el desarrollo de software, especialmente de programas orientados a objetos. En su forma general, la LoD es un caso específico de acoplamiento débil.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cada unidad debe tener un conocimiento limitado sobre otras unidades: sólo se deben tratar con las unidades “estrechamente” relacionadas.&lt;/li&gt;
  &lt;li&gt;Cada unidad debería hablar sólo con sus amigos; no hablar con extraños.&lt;/li&gt;
  &lt;li&gt;Y sólo, con sus amigos inmediatos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La noción fundamental es que un objeto determinado debe suponer lo menos posible sobre la estructura o las propiedades de cualquier otra cosa (incluidos sus subcomponentes), de acuerdo con el principio de “ocultación de información”. Puede considerarse como un corolario del principio de mínimo privilegio, que dicta que un módulo sólo posee la información y los recursos necesarios para su propósito legítimo&lt;/p&gt;

&lt;h3 id=&quot;reglas&quot;&gt;Reglas&lt;/h3&gt;

&lt;p&gt;Así pues, de acuerdo a LoD, y los elementos que componene este patrón de arquitectura, las interacciones que se pueden dar entre ellos son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cada caso de uso se representa por una clase de control&lt;/li&gt;
  &lt;li&gt;Cada relación entre el caso de uso y un actor, se representa por una clase Boundary&lt;/li&gt;
  &lt;li&gt;Los actores solo conocen y se comunican con boundaries.&lt;/li&gt;
  &lt;li&gt;Las boundaries deben comunicarse exclusivamente con actores y clases de control&lt;/li&gt;
  &lt;li&gt;Los controladores se comunican con boundaries y entidades, y si lo requiriesen con otros controladores&lt;/li&gt;
  &lt;li&gt;Las entidades, pueden comunicarse con otras entidades o controladores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Entity-control-boundary&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbertograca.com/2017/08/24/ebi-architecture/#more-10264&quot;&gt;EBI Architecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ebi.readthedocs.io/en/latest/core.html&quot;&gt;Entity-Boundary-Interactor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.programmersought.com/article/9051259027/&quot;&gt;Java Terminology&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.visual-paradigm.com/guide/uml-unified-modeling-language/robustness-analysis-tutorial/&quot;&gt;A Practical Tutorial on Robustness Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/ebc</link>
        <guid isPermaLink="true">http://localhost:4000/ebc</guid>
        
        <category>Diseño</category>
        
        <category>Arquitectura</category>
        
        
      </item>
    
  </channel>
</rss>
