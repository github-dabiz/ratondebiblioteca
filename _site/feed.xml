<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ratón de Biblioteca</title>
    <description>Ratón de Biblioteca es un blog dedicado al diseño de software en el ecosistema Java.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 07 Nov 2021 12:06:08 +0100</pubDate>
    <lastBuildDate>Sun, 07 Nov 2021 12:06:08 +0100</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>RBAC - Role based access Control</title>
        <description>&lt;p&gt;El control de acceso basado en roles es un paradigma de seguridad que permite controlar las acciones que los usuarios de un sistema/organización pueden realizar sobre los recursos del mismo, en función de los privilegios por rol. Se basa en una estructura de tres niveles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;usuarios&lt;/li&gt;
  &lt;li&gt;roles&lt;/li&gt;
  &lt;li&gt;grupos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tiene como objetivo asegurar la confidencialidad, integridad y disponibilidad de la información.&lt;/p&gt;

&lt;p&gt;Normalmente empresas y organizaciones, quieren proteger sus datos de accesos y cambios no autorizados. Tradicionalmente para garantizar la seguridad, las el control de acceso se gestionaba de forma individual mediante &lt;em&gt;listas de control de acceso&lt;/em&gt; (ACL - access control list). El problema de este tipo de mecanismo de control es que tanto el coste de mantenimiento, como el número de errores de gestión, aumentan a medida que aumenta el número de usuarios a gestionar.&lt;/p&gt;

&lt;p&gt;Sin embargo RBAC es un modelo en el que se puede aplicar una política de seguridad a un nivel más específico, mediante el &lt;strong&gt;&lt;em&gt;principio de seguridad del privilegio mínimo&lt;/em&gt;&lt;/strong&gt;. Este principio se basa en la idea de que un usuario debe disponer de los privilegios mínimos necesarios para realizar su trabajo. Los roles abstraen los procesos del trabajo de una organización, pueden variar entre organizaciones, y pueden referirse a aspectos diversos como departamentos, ubicaciones, centros, o funciones de los empleados.&lt;/p&gt;

&lt;p&gt;Los roles deben estar orientados a la estructura organizativa de la empresa. Se deben identificar todas las autorizaciones que cada empleado de la organización necesita, tales como acceso a internet, aplicaciones, recursos de red, o inicio de sesión.&lt;/p&gt;

&lt;h2 id=&quot;implementación&quot;&gt;Implementación&lt;/h2&gt;

&lt;p&gt;Lo primero que debe hacerse al implementar un mecanismo RBAC es determinar qué funciones se van a desempeñar en cada puesto o departamento, para en base a ellas, identificar las herramientas y/o recursos que se necesitan para llevarlas a cabo.&lt;/p&gt;

&lt;p&gt;En segundo lugar se procederá a la asignación de roles, donde habrá que que tener en cuenta que:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;los roles se asignan a los empleados según sus tareas o puesto en la empresa&lt;/li&gt;
  &lt;li&gt;se puede asignar uno o más roles por usuario&lt;/li&gt;
  &lt;li&gt;Se pueden combinar los privilegios por rol con la asignación de privilegios de forma individual.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por último, será necesario identificar el &lt;strong&gt;&lt;em&gt;Ámbito&lt;/em&gt;&lt;/strong&gt; al que se aplica el control de acceso, entendiendo por ámbito el conjunto de recursos. Los más habituales incluyen:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Derechos a los datos (read, read and write, full access)&lt;/li&gt;
  &lt;li&gt;Derechos de acceso a aplicaciones&lt;/li&gt;
  &lt;li&gt;Autorización de solicitudes&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
 &lt;img class=&quot;image-center&quot; src=&quot;/assets/images/posts/2021/20211105rbac/20211105model-image.png&quot; alt=&quot;modelo entidad-relación RBAC&quot; /&gt;
&lt;figcaption class=&quot;figure-caption&quot;&gt;modelo entidad-relación RBAC&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;asignación-de-permisos&quot;&gt;Asignación de permisos&lt;/h3&gt;

&lt;p&gt;La asignación de permisos, se realiza a tres niveles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se deben identificar las autorizaciones que necesitan los individuos que pertenecen a un mismo &lt;strong&gt;&lt;em&gt;grupo de trabajo&lt;/em&gt;&lt;/strong&gt;, como es el caso de un &lt;strong&gt;&lt;em&gt;departamento&lt;/em&gt;&lt;/strong&gt;. Las autorizaciones correspondientes se asignan a todos los empleados de cada departamento.&lt;/li&gt;
  &lt;li&gt;A otro nivel de abstracción, es necesario definir funciones de un puesto y sus tareas implicadas, que pueden corresponder a un subconjunto dentro del departamento, o a un rol desempeñado de forma individual.&lt;/li&gt;
  &lt;li&gt;Por último es posible asignar a cada empleado los roles adicionales que necesite&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;modelos&quot;&gt;Modelos&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC plano&lt;/em&gt;&lt;/strong&gt;. Es el modelo base.
    &lt;ul&gt;
      &lt;li&gt;A los usuarios se les asignan roles que tienen asignados privilegios, de forma que a través de un rol, los usuarios adquieren permisos.&lt;/li&gt;
      &lt;li&gt;Requiere que el usuario-rol y el permiso-rol se pueda asignar de muchos a muchos
        &lt;ul&gt;
          &lt;li&gt;Un usuario puede ser asignado a muchos roles&lt;/li&gt;
          &lt;li&gt;Un rol puede ser asignado a muchos usuarios&lt;/li&gt;
          &lt;li&gt;Un permiso puede ser asignado a muchos roles&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;Implica la revisión del rol de los usuarios&lt;/em&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC jerárquico&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Incluye las características del RBAC Plano, pero además los roles se organizan por jerarquías
        &lt;ul&gt;
          &lt;li&gt;Los roles superiores contienen los permisos de los roles inferiores&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Deja la definición de jerarquías abierta, para que cada organización define la suya.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC restringido&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Tiene en cuenta la separación de funciones, como un sistema creado para minimizar la comisión de actos fraudulentos. Se basa en la necesidad de implicar a más de un miembro o empleado para completar una tarea.&lt;/li&gt;
      &lt;li&gt;Determinados accesos y acciones requieren de los permisos de más de un rol&lt;/li&gt;
      &lt;li&gt;Puede ser estático o dinámico (implica activación de roles)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;RBAC simétrico&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Implica que se puedan revisar y ajustar los roles y permisos de cada función de forma periódica, para poder adaptarse a los cambios de forma efectiva.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ventajas&quot;&gt;Ventajas&lt;/h2&gt;

&lt;p&gt;Entre las principales ventajas de RBAC destacan:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Flexibilidad&lt;/em&gt;&lt;/strong&gt;. Los cambios en la estructura organizativa o autorizaciones se pueden modificar rápidamente.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Administración&lt;/em&gt;&lt;/strong&gt;. Su administración es mucho menos costosa que la gestión de permisos individuales, y se cometen muchos menos errores en su gestión&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Eficiencia&lt;/em&gt;&lt;/strong&gt;. Gracias a la mejora en la administración el proceso es más eficiente, pudiendo automatizarse y disminuyendo los tiempos de espera.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Seguridad&lt;/em&gt;&lt;/strong&gt;. Aumenta la seguridad gracias al &lt;strong&gt;&lt;em&gt;Principio del Menor Privilegio&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Transparencia&lt;/em&gt;&lt;/strong&gt;. Al estar basada en roles, la administración se simplifica, y es más fácil de entender la política aplicada.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;desventajas&quot;&gt;Desventajas&lt;/h2&gt;

&lt;p&gt;Sin embargo, la adopción de este sistema de control de accesos conlleva una serie de inconvenientes a tener en cuenta:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Elaboración&lt;/em&gt;&lt;/strong&gt;. Transferir la estructura organizativa a un modelo de control de accesos es laborioso.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Conveniencia&lt;/em&gt;&lt;/strong&gt;. Para modelos organizativos pequeños, la asignación de permisos individuales puede ser más ágil.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fuentes&quot;&gt;Fuentes&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E24842_01/html/E23286/rbac-1.html&quot;&gt;Oracle. Guía de administración del sistema: servicios de seguridad&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ionos.es/digitalguide/servidores/seguridad/que-es-el-role-based-access-control-rbac/&quot;&gt;Ionos Digital Guide. Role based access control (RBAC): ¿Cómo funciona el control de acceso basado en roles?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.manageengine.com/es/device-control/role-based-access-control.html&quot;&gt;Manage Engine. Prevenga los ataques basados en archivos con un control de acceso efectivo basado en roles&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://protecciondatos-lopd.com/empresas/control-de-acceso-basado-en-roles-rbac/&quot;&gt;Ático 34. Control de acceso basado en roles (RBAC): Una forma de mejorar la seguridad del sistema&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rawpixel.com&quot;&gt;Foto de Gráfico creado por rawpixel.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 05 Nov 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/role-based-access-control</link>
        <guid isPermaLink="true">http://localhost:4000/role-based-access-control</guid>
        
        <category>seguridad</category>
        
        
      </item>
    
      <item>
        <title>Arquitectura hexagonal</title>
        <description>&lt;p&gt;Propuesta en 2005 por &lt;a href=&quot;http://web.archive.org/web/20180121161736/http://alistair.cockburn.us/Hexagonal+Architecture&quot;&gt;Alistair Cockburn&lt;/a&gt;, también conocida como arquitectura de puertos y adaptadores, su finalidad es desacoplar las capas de la aplicación, y permitir así que evolucionen de forma aislada. La forma de conseguirlo, considerar el dominio como el núcleo de la arquitectura, y proteger su estructura de interacciones con elementos externos.&lt;/p&gt;

&lt;p&gt;El motivo de representar este tipo de arquitecturas como un hexágono, es arbitrario, lo que pretende reflejar es el hecho de que las comunicaciones con el exterior tienen la misma naturaleza y deben asumir las mismas reglas.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;La consecuencia que se deriva de aplicar esta arquitectura, es desarrollar aplicaciones que son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Independientes de agentes externos&lt;/li&gt;
  &lt;li&gt;Independientes de framework&lt;/li&gt;
  &lt;li&gt;Independientes de la UI&lt;/li&gt;
  &lt;li&gt;Independientes de BBDD&lt;/li&gt;
  &lt;li&gt;Más adaptables&lt;/li&gt;
  &lt;li&gt;Más reutilizables&lt;/li&gt;
  &lt;li&gt;Más mantenibles&lt;/li&gt;
  &lt;li&gt;Más testeables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;motivación&quot;&gt;Motivación&lt;/h2&gt;

&lt;p&gt;En su origen, Alistair Cockburn hacía mucho énfasis en evitar la infiltración de la lógica de negocio en la interfaz de usuario. Ya que si esto se produce, da lugar a una arquitectura fuertemente acoplada entre el frontend y el backend.&lt;/p&gt;

&lt;p&gt;Su propuesta pretende mejorar las siguientes áreas durante el ciclo de vida del producto:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;automatización de pruebas&lt;/li&gt;
  &lt;li&gt;desacoplamiento de los detalles de infraestructura&lt;/li&gt;
  &lt;li&gt;conexion con nuevos agentes&lt;/li&gt;
  &lt;li&gt;abstraer el dominio de la comunicación con agentes externos, usuarios, comandos, lotes, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Según él, la raíz del problema está en la interacción entre el interior y el exterior, la regla es que los detalles del código interior no deben filtrarse al exterior.&lt;/p&gt;

&lt;p&gt;Para conseguirlo, propone utilizar el patrón de puertos y adaptadores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Los &lt;strong&gt;puertos&lt;/strong&gt; son las interfaces que definen la interacción con el exterior y exponen únicamente el contrato con nuestro dominio, dejando que toda la lógica de transformación esté de puertas afuera y no se contamine el interior. Pueden ser de varios tipos:
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;de entrada&lt;/strong&gt;. Sirven para hacer peticiones a la aplicación&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;de salida&lt;/strong&gt;. Sirven para solicitar información desde la aplicación&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;de entrada/salida&lt;/strong&gt;. En general son adaptadores bidireccionales a un recurso. No representan comunicación bidireccional, sino que la aplicación es capaz de escuchar peticiones del recurso y hacerle peticiones.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Los &lt;strong&gt;adaptadores&lt;/strong&gt; son precisamente la forma de conectarse a través de dicho contrato. Establecen la comunicación y la conversión de datos entre el dominio y el exterior. Lo relevante en esta interacción, es que los adaptadores no pertenecen al core, así que pueden implementarse por separado. Para cada dispositivo externo habrá un adaptador, y será de entrada o salida dependiendo del sentido de la comunicación. Por lo general habrá varios adaptadores para cada tipo de puerto, uno por tipo de tecnología o agente que puede conectarse a ese puerto.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Además, diferencia entre dos tipos de puertos y adaptadores. Los &lt;strong&gt;primarios o driving&lt;/strong&gt;, son los que habilitan conexiones hacia nuestra aplicación, y los &lt;strong&gt;secundarios&lt;/strong&gt; que permiten conexiones desde nuestra aplicación. También tienen otra particularidad, en los que conectan la UI con la aplicación, el adaptador pertence a la capa de aplicación (API) del caso de uso, mientras que en el caso de backend, es éste el que inyecta el adaptador específico para permitir la comunicación con la utilidad. El núcleo en ambos casos solo debe conocer la interfaz.&lt;/p&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; -webkit-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!-- -moz-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; border-radius: 10px;
box-shadow: 0 0 15px #ddd;&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/20210205_111.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center;&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;puertos y adaptadores&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;h2 id=&quot;arquitectura-hexagonal-y-ddd&quot;&gt;Arquitectura hexagonal y DDD&lt;/h2&gt;

&lt;p&gt;Al ser el dominio el elemento en torno al cual se define este enfoque, encaja muy bien con la idea de &lt;strong&gt;Domian Driven Design&lt;/strong&gt;, ya que se puede implementar su lógica sin atender a detalles específicos.&lt;/p&gt;

&lt;p&gt;Sin embargo, un punto de vista crítico con todo este planteamiento, que considero muy interesante es el de &lt;a href=&quot;https://javiervelezreyes.com/ni-nueva-ni-arquitectura-ni-hexagonal/&quot;&gt;Javier Vélez Reyes - Ni Nueva Ni Arquitectura Ni Hexagonal&lt;/a&gt;, que argumenta razonadamente en contra de esta propuesta, como un enfoque geniunamente arquitectónico y rebajándolo a un tipo de patrón o recomendación de buenas prácticas, que símplemnte aglutina conceptos preexistentes.&lt;/p&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.archive.org/web/20180121161736/http://alistair.cockburn.us/Hexagonal+Architecture&quot;&gt;Alistair Cockburn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@edusalguero/arquitectura-hexagonal-59834bb44b7f&quot;&gt;Edu Slaguero: Arquitectura hexagonal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.allegro.tech/2020/05/hexagonal-architecture-by-example.html&quot;&gt;Allegro Tech Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbertograca.com/2017/09/14/ports-adapters-architecture/&quot;&gt;hgraca&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.adictosaltrabajo.com/2019/07/02/capas-cebollas-y-colmenas-arquitecturas-en-el-backend/&quot;&gt;Capas, cebollas y colmenas: arquitecturas en el backend&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://javiervelezreyes.com/ni-nueva-ni-arquitectura-ni-hexagonal/&quot;&gt;Ni Nueva Ni Arquitectura Ni Hexagonal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 05 Feb 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/arquitectura-hexagonal</link>
        <guid isPermaLink="true">http://localhost:4000/arquitectura-hexagonal</guid>
        
        <category>Diseño</category>
        
        <category>Arquitectura</category>
        
        
      </item>
    
      <item>
        <title>Entity-Boundary-Control</title>
        <description>&lt;p&gt;Aunque la dio a conocer Robert C. Martin, fue propuesta por Ivar Jacobson en 1992. Su nombre original, Entity-Interface-Control, se cambió para evitar confusiones con conceptos similares de los lenguajes de programación. Es un patrón arquitectónico utilizado en el diseño de software orientado a objetos, en el que los casos de uso categorizan las clases que componen el software según su responsabilidad.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“La arquitectura de una aplicación se rige por sus casos de uso.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jacobson, proponía este modelo para el análisis y diseño de actividades, y su representación mediante sus estereotipos UML.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Su propósito, producir una arquitectura agnóstica a la implementación, que no esté atada a una plataforma, aplicación, lenguaje o marco específico; y cuyos elementos estén unidos por un acoplamiento lo más débil posible. Esta es su principal diferencia con MVC, ya que ni controladores ni entidades, conocen el medio por el que se está accediendo a ellas. En MVC, siempre hay una dependencia con el mecanismo de entrega.&lt;/p&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; -webkit-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!-- -moz-box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--box-shadow: 12px 29px 81px 0px rgba(0,0,0,0.75);--&gt;
&lt;!--&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center; border-radius: 10px;
box-shadow: 0 0 15px #ddd;&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;!--&lt;figure&gt;--&gt;
&lt;!--    &lt;img src=&quot;/assets/images/posts/2021/EBC/20210125_1.jpg#wide&quot; alt=&quot;Esquema&quot; style=&quot;margin-left: auto; margin-right: auto; display: block; width: 90%; height: auto; alignment: center;&quot;/&gt;--&gt;
&lt;!--    --&gt;
&lt;!--    &lt;figcaption class=&quot;caption-text&quot;&gt;flujo boundary-controller-entity&lt;/figcaption&gt;--&gt;
&lt;!--    --&gt;
&lt;!--&lt;/figure&gt;--&gt;

&lt;p&gt;Sus responsabilidades:&lt;/p&gt;

&lt;h2 id=&quot;entity&quot;&gt;Entity&lt;/h2&gt;

&lt;p&gt;Las entidades contienen los datos utilizados por el sistema y los cálculos asociados a estos. Cada entidad representa un concepto relevante dentro del dominio del problema, y mantiene la identidad de los datos persistentes.&lt;/p&gt;

&lt;p&gt;Adicionalmente, Jacobson propone que la naturaleza de la lógica de la entidad, es tal, que si la estructura de los datos que contiene cambia, las operaciones sobre estos datos también tendrán que cambiar. Por eso deben estar ubicados juntos.&lt;/p&gt;

&lt;p&gt;Por lo tanto, al igual que defienden otros autores, esta recomendación va en contra de lo que actualmente se conoce como entidades anémicas &lt;a href=&quot;https://es.wikipedia.org/wiki/Modelo_de_dominio_an%C3%A9mico&quot;&gt;modelo anémico&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;boundary-interfaz&quot;&gt;Boundary (interfaz)&lt;/h2&gt;

&lt;p&gt;Se trata de los objetos que modelan todas las interacciones del sistema con los actores externos. Cualquier interacción del sistema con un actor, debe pasar por un objeto Boundary. Ya sea la implementación de la funcionalidad para el procesamiento de datos para una interfaz grafica de usuario o de un API web. Por lo tanto su naturaleza es funcional, aceptan solicitudes y producen respuestas como ressultado.&lt;/p&gt;

&lt;h2 id=&quot;controlador&quot;&gt;Controlador&lt;/h2&gt;

&lt;p&gt;La relevancia de este último tipo de objeto es proporcionar la comunicación entre interfaces y entidades, evitando que éstas últimas propaguen su lógica a los actores externos con los que se comunican.&lt;/p&gt;

&lt;p&gt;Los controladores, según Jacobson son aquellos que orquestan un caso de uso, así como los objetos que contengan un comportamiento relevante para éste y que no sean una entidad o una interfaz. Aceptan peticiones de o límites, deciden qué hacer con ellas y manipulan el estado de la aplicación. Por tanto conocen los modelos de petición y respuesta, &lt;a href=&quot;https://www.programmersought.com/article/9051259027/&quot;&gt;&lt;strong&gt;DTO’s&lt;/strong&gt;&lt;/a&gt;. De alguna manera son la implementación concreta de los límites.&lt;/p&gt;

&lt;h2 id=&quot;interacciones&quot;&gt;Interacciones&lt;/h2&gt;

&lt;p&gt;En cuanto a las interacciones que se pueden dar entre los tres tipos de objetos, deben ser tales, que respeten la Ley de Demeter LoD, o principio del mínimo conocimiento. Se trata de una directriz de diseño para el desarrollo de software, especialmente de programas orientados a objetos. En su forma general, la LoD es un caso específico de acoplamiento débil.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cada unidad debe tener un conocimiento limitado sobre otras unidades: sólo se deben tratar con las unidades “estrechamente” relacionadas.&lt;/li&gt;
  &lt;li&gt;Cada unidad debería hablar sólo con sus amigos; no hablar con extraños.&lt;/li&gt;
  &lt;li&gt;Y sólo, con sus amigos inmediatos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La noción fundamental es que un objeto determinado debe suponer lo menos posible sobre la estructura o las propiedades de cualquier otra cosa (incluidos sus subcomponentes), de acuerdo con el principio de “ocultación de información”. Puede considerarse como un corolario del principio de mínimo privilegio, que dicta que un módulo sólo posee la información y los recursos necesarios para su propósito legítimo&lt;/p&gt;

&lt;h3 id=&quot;reglas&quot;&gt;Reglas&lt;/h3&gt;

&lt;p&gt;Así pues, de acuerdo a LoD, y los elementos que componene este patrón de arquitectura, las interacciones que se pueden dar entre ellos son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cada caso de uso se representa por una clase de control&lt;/li&gt;
  &lt;li&gt;Cada relación entre el caso de uso y un actor, se representa por una clase Boundary&lt;/li&gt;
  &lt;li&gt;Los actores solo conocen y se comunican con boundaries.&lt;/li&gt;
  &lt;li&gt;Las boundaries deben comunicarse exclusivamente con actores y clases de control&lt;/li&gt;
  &lt;li&gt;Los controladores se comunican con boundaries y entidades, y si lo requiriesen con otros controladores&lt;/li&gt;
  &lt;li&gt;Las entidades, pueden comunicarse con otras entidades o controladores.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Entity-control-boundary&quot;&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://herbertograca.com/2017/08/24/ebi-architecture/#more-10264&quot;&gt;EBI Architecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ebi.readthedocs.io/en/latest/core.html&quot;&gt;Entity-Boundary-Interactor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.programmersought.com/article/9051259027/&quot;&gt;Java Terminology&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.visual-paradigm.com/guide/uml-unified-modeling-language/robustness-analysis-tutorial/&quot;&gt;A Practical Tutorial on Robustness Analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/ebc</link>
        <guid isPermaLink="true">http://localhost:4000/ebc</guid>
        
        <category>Diseño</category>
        
        <category>Arquitectura</category>
        
        
      </item>
    
  </channel>
</rss>
